# Web APIの概要と実際の開発・運用事例

## 何について書いているのか

Software Design8月号のWeb API特集の内容のまとめと感想・考察など。
特に実際に案件で開発進める上で活かせそうな内容を中心にまとめる。



## なんでこれを書こうと思ったのか

WORK AGILEの開発をしていて、岩崎さんが「Railsはスッカスカ」って言ってたのを聞き、自分でもRailsのAPI設計がもっとしっかりしていればバグを減らせたり、開発スピードを向上させられるんじゃないかと思ったため。



## 本編まとめ

特に気になったところだけpick up

### Web APIがなぜ必要なのか？

ひとつのwebサービスでユーザーが触れるポイントが多数存在するようになった。
ex. WORK AGILEでいう、スマホ版とPC版で同じ機能が利用されている点などを考えるとわかりやすいかも
API化せずにサーバーサイドでHTMLを生成する仕組みだと、同じビジネスロジックを複数の画面から再利用するのが難しい。よってAPIとしてビジネスロジックだけを抽象化して管理し、複数の画面から再利用できるようにする

つまり、再利用できることがAPIにとっては重要ってわけだ。

### 再利用できることのビジネス的なメリット

APIが再利用できるってことは要するに複数のAPIを組み合わせて別の機能を作ったり、別のサービスを作ったりできるってことだ。
ex. 決済サービスやGoogle MAPのAPIは他のサービスで再利用されているよね
この部分読んでわかると思うが、APIは再利用可能な形で開発し画面間で使い回しが効くようにするのがベストってわけだね。



### APIの4原則と実際のGood Badの例

- Stateless...リクエストがクライアントの状態に依存していないこと(クライアントの状態によってAPIの処理内容がかわらないようにする)
  ex. response.title = 'test' OK / response.titile = 'title#{request_number}' NG (上手い例かどうかは若干怪しい)

- Addressability...URLがリソースごとに一意
  ex. GET /members ... 一覧 GET /members/1 ... 詳細 

- Uniform Interface...HTTPメソッドとAPIの内容が対応している
  ex. GET→リソースの取得, POST...リソースの投稿

- Connectability...別なリソースへのアクセス情報をレスポンスとして提供している
  ex. response.nextPage = 'http://...'



### Open APIの実例

**クラウドサイン**
https://app.swaggerhub.com/apis/CloudSign/cloudsign-web_api/0.19.1
yamlまで見れる。すげぇ

**freee 会計**
https://raw.githubusercontent.com/freee/freee-api-schema/master/v2020_06_15/open-api-3/api-schema.json
こっちはswagger hubとか使っていないのでちょっと読みづらいけどこれもjsonで見れる。すごい。便利な時代。



### REST APIの設計で検討すること

**HTTPメソッドとURI**
要するにリソース単位でURIを組みましょう。
その方がユーザー目線でも開発者目線でもわかりやすいよねって話(ログからデバッグする時とかも変なURIだとわかりづらそう)

↓みたいなのは避けようね

- システムの構成が反映されたURI(わかりやすのは環境名とかかな？)
  - サーバーサイドの構成が見えてしまうなどの脆弱性リスクもある
- エンコードを必要とするURI
- 意味のわからない略称

HTTPメソッドはまぁいつも意識していることなのであえて書かない。

ちなみにリソースベースのURIでは慣例として↓が採用される

- 小文字
- 複数形

**パラメータ設計**

基本は↓で分ける

- パスパラメータ...リソースを指定するのに必須の情報(idなど)
- クエリパラメータ...リソースを指定する際に必須ではなく、複数必要になる条件(検索条件など)

### APIのバージョン管理

v1とかv2を管理するケースってどう言う時？
→他の開発者にAPIを使ってもらう場合。自分達しか使わないAPIならバージョン番号はつけなくてもいい。

バージョン番号をつけるとシンプルに管理するAPIが増えるので、管理コストがかかる。バージョンによって処理内容が違ったりするので。

(前の案件でこういうので瀬尾さんに相談した記憶)

### ステータスコードについて

エラーなのに200番みたいなのは避けましょう(って前の案件で言われた思い出)

※API利用者がAPI間でのリダイレクトを想定していないケースも多いのでリダイレクトの利用は基本避ける

### レスポンスの設計で気をつけること

- レスポンスヘッダに含まれる情報はボディには含めない
- オブジェクトのjsonの構造はフラットにする(WORK AGILEではめっちゃやっちゃってますね・・・)
- エラー時はエラーメッセージを含める(これはいつもやってる)
- サービス閉鎖時は503ステータスで、Retry Afterヘッダーをレスポンスに含める(こりゃ知らんかった)

### 多量アクセス対策

レートリミットという時間単位のアクセス制限をつける。

- 誰に...JWTとかリソースIDとかを使うケースが多いらしい
- どの単位で...API全体を使うのが簡単
- どの時間単位で
- 何回まで

アクセス許可するかを設定する。キャンペーン対応などではユーザーのIDやJWTを使って特定ユーザーへのアクセス制限の緩和をおこなったりするらしい。へぇ

### Open APIの開発

Open APIの開発では主に以下の3つを行う

- 定義ファイルの作成
- クライアントライブラリの実装
- モックサーバーの実装

特に個人的に魅力的だなぁと思ったのはモックサーバーの実装で、これがあるとモックサーバーだけ用意しておいてフロントの開発をサクッと進められたりするんかなと思った。WORK AGILEではバックエンドとフロントエンドがほぼ完全に結合しちゃってるのでそこが開発スピードの遅延とかにつながっているんかなと。

定義ファイルの作成はstoplightとか使うんだけどこれはGMOくまぽんでやってるらしくちょっと羨ましい。

ようするにstoplightでOpen APIのyamlを作成し、Open API GeneratorでAPIを実装し Prismでモックサーバーとして動かす。そうするとフロントの開発がさくさく進むってわけだな。レスポンスによってUIを分ける時とかにわざわざDBいじらなくてよかったりとメリット多そう。くう案件でやりたいねぇ。

あとこの3つを中心にAPI開発をしている限りはyamlだけ管理すれば開発内容の変更ができるのでメンテナンスコストも低くてすみそうだなと思いました。

### yamlを書くときに気をつけること

雑誌には以下の4つが書いてあった

- schemaやプロパティの命名規則(スネークケース、キャメルケースなど)
- nullとundefinedの扱い。必須ではない型はrequiredを使い、nullやundefinedの使用は避けるようにするといいってよ
- allOf, oneOfといったof系は使わない(調べた感じ、複数のschemaを一つのAPIに割り当てるときに使うっぽい)

https://swagger.io/docs/specification/data-models/oneof-anyof-allof-not/

- yamlファイルはコンフリクトを避けるために分割して開発し、後で結合する(swagger cliというのでできるらしい)

### モックサーバーの運用時に気をつけること

**ユースケース別にレスポンスを分けたい場合**
yamlファイルにexamplesを定義しPreferヘッダで分ける(むちょ便利や〜)。ステータスコードをPreferヘッダに加えればステータス別の検証も可能。素敵！

**動的にレスポンスを変動させたい場合**
ダイナミックレスポンスってやつが使えるらしい。yamlファイルから動的にレスポンスを生成してくれるってよ。
Prismの起動時に-dを指定するなどすればいいらしい
→極端な値が入った場合のUI表示などを検証できる！

### Open APIのテスト

Dreddってやつを使うとAPIがyamlファイルの定義に一致するかテストできるらしい。
これは便利そうだけど、新規開発でここまでやっちゃうと開発スピード落ちそうで怖い

### Open APIをCIする

基本以下のステップ。じゅくみ〜るこんな感じだったな。

- yamlファイルの検証](書き方があっているか)
- yamlファイルから生成したソースコードがyamlの定義に沿っているかの検証
- 各テストの実装

多分Railsだとテストコードに、comitteeというgemを使うことでレスポンスの型がyamlと一致しているかを検証できるって感じだったかなと思う



